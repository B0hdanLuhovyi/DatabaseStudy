Аналіз оптимізації SQL-запиту за допомогою EXPLAIN

Цей документ описує процес аналізу та оптимізації SQL-запиту до таблиці Order у базі даних posters.

Мета: Продемонструвати вплив індексування на план виконання запиту, що фільтрує дані за неключовим полем (status).

Аналіз "ДО" оптимізації

Першим кроком ми аналізуємо план запиту, який шукає всі замовлення зі статусом 'Pending', до створення будь-яких індексів для цього поля.

Запит:
EXPLAIN SELECT * FROM Order WHERE status = 'Pending';

План виконання (на основі наданого скріншоту):

select_type: SIMPLE
table: Order
type: ALL
possible_keys: [NULL]
key: [NULL]
rows: 11
Extra: Using where

Інтерпретація:

type: ALL: Це ключовий показник. Він означає "Full Table Scan" (Повний перебір таблиці).

key: [NULL]: База даних не змогла знайти (і, відповідно, використати) жодного релевантного індексу.

rows: 11: MariaDB очікує, що їй доведеться прочитати та перевірити всі 11 рядків (або всю таблицю, якою б великою вона не була)

Висновок: Цей запит є вкрай неефективним. Зі зростанням таблиці Order час виконання цього запиту буде лінійно погіршуватися.

Крок оптимізації: Створення індексу

Щоб вирішити проблему повного сканування, ми створюємо індекс для стовпця status, оскільки саме він використовується у WHERE.

Команда:
CREATE INDEX idx_order_status ON Order (status);

Що це робить: Ця команда створює нову B-Tree структуру (індекс) idx_order_status. Тепер СУБД може миттєво знайти всі рядки зі статусом 'Pending'.

Аналіз "ПІСЛЯ" оптимізації

Ми негайно запускаємо EXPLAIN для того ж самого запиту, щоб побачити, як змінився план виконання.

Запит:
EXPLAIN SELECT * FROM Order WHERE status = 'Pending';

План виконання (на основі наданого скріншоту):

select_type: SIMPLE
table: Order
type: ref
possible_keys: idx_order_status
key: idx_order_status
rows: 1
Extra: Using index condition

Інтерпретація:

type: ref: Це величезне покращення. Замість ALL (сканування), СУБД виконує ref (пошук за посиланням/індексом).

key: idx_order_status: План чітко показує, що оптимізатор вирішив використати наш щойно створений індекс idx_order_status.

rows: 1: Очікувана кількість рядків, які потрібно обробити, різко впала.

Висновок: Запит тепер є високоефективним і буде виконуватися майже миттєво, незалежно від того, скільки мільйонів замовлень буде в таблиці Order.

Загальний висновок

Порівняння планів:

Метрика: type
До оптимізації: ALL
Після оптимізації: ref
Результат: Значне покращення

Метрика: key
До оптимізації: NULL
Після оптимізації: idx_order_status
Результат: Індекс використовується

Метрика: rows (оцінка)
До оптимізації: ~11 (Вся таблиця)
Після оптимізації: ~1 (Лише потрібні рядки)
Результат: Ефективність

Аналіз EXPLAIN довів, що просте створення індексу idx_order_status на стовпці status кардинально змінило план виконання запиту, перетворивши неефективний "Full Table Scan" на швидкий "Index Seek".
